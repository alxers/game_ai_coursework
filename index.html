<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title></title>
    <style type="text/css">
      canvas { border: 1px solid black; }
    </style>
  </head>
  <body">
    <canvas id="ai" width="800" height="200"></canvas>
    <script type="text/javascript">
      //https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Finishing_up

      // Declare as variable
      var canvas;
      var ctx;
      var secondsPassed;
      var oldTimeStamp;
      var fps;

      var dx = 0.2;
      var dy = -0.2;

      // Circles variables
      var circleRadius = 10;
      var maxCircles = 12;
      var existingCircles = [];
      // end Circles variables

      // Vehicle object
      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rotate
      var vehicle = {
        x: 0,
        y: 0,
        width: 20,
        height: 20,
        velocity: 0,
        mass: 5,
        maxSpeed: 20,
        maxForce: 4
      };
      // end Vehicle object


      //
      //


      // Listen to the onLoad event
      window.onload = init;

      // Trigger init function when the page has loaded
      function init() {
        canvas = document.getElementById('ai');
        ctx = canvas.getContext('2d');

        vehicle.x = randFromTo(20, canvas.width - 20);
        vehicle.y = randFromTo(20, canvas.height - 20);

        // Request an animation frame for the first time
        // The gameLoop() function will be called as a callback of this request
        // https://developer.mozilla.org/en-US/docs/Games/Anatomy#building_a_more_optimized_main_loop_in_javascript
        window.requestAnimationFrame(gameLoop);
      }

      function gameLoop(timeStamp) {

        // Calculate the number of seconds passed since the last frame
        secondsPassed = (timeStamp - oldTimeStamp) / 1000;
        oldTimeStamp = timeStamp;
        // tNow = timeStamp;

        // // Calculate fps
        // fps = Math.round(1 / secondsPassed);

        // Perform the drawing operation
        draw(timeStamp, secondsPassed);

        // The loop function has reached it's end
        // Keep requesting new frames
        window.requestAnimationFrame(gameLoop);
      }

      function draw(timeStamp, secondsFromLastFrame) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        var ts = timeStamp / 1000;

        updateVehicle(secondsFromLastFrame);
        drawVehicle(ts);
        drawCircles(ts);
        collisionDetection();
      }

      // Vehicle physics
      // https://lamberta.github.io/html5-animation/

      function updateVehicle(ts) {
        // vehicle.force = calculateSteeringForce();
        var target = findClosestCircle();
        // vehicle.force = seek(target.x, target.y);
        // vehicle.acceleration = vehicle.force / vehicle.mass;
        // // Check timeStamp here, should probably be time elapsed from previous frame?
        // // Originally it's m_TimeElapsed = (m_CurrentTime - m_LastTimeInTimeElapsed) * m_TimeScale;
        // vehicle.velocity += vehicle.acceleration * ts;
        // // Truncate to maxSpeed if needed;
        // truncate();
        // updatePos();
      }
      // end Vehicle physics

      // AI functions
      function seek(targetPos) {
        var desiredVelocity = normalize(targetPos - vehicle.pos) * vehicle.maxSpeed;
        return (desiredVelocity - vehicle.velocity);
      }
      //


      // Helper

      function drawVehicle(ts) {
        ctx.fillStyle = '#ff8080';
        ctx.fillRect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
      }

      function drawCircle(x, y, type) {
        var color = '#880000';
        if (type == 2) {
          color = '#0095DD';
        }

        ctx.beginPath();
        ctx.arc(x, y, circleRadius, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
      }

      function drawCircles(ts) {
        if (randFromTo(0, 1000) > 993 && existingCircles.length < maxCircles) {
          existingCircles.push(createCircle());
        }

        var circleIndexesToRemove = [];

        for (var i = 0; i < existingCircles.length; i++) {
          var currCircle = existingCircles[i];
          currCircle.tStart ||= ts;
          // TODO: check if this works correcly (count seconds for one circle)
          // another option is to have "secondsPassed" and
          // currCircle.timePassed += secondsPassed, then check if timePassed <= lifetime ?
          // The current implementation uses "Static" time? (runs at different speed on different computers) ?
          // https://developer.ibm.com/tutorials/wa-build2dphysicsengine/
          if (ts - currCircle.tStart <= currCircle.lifetime) {
            drawCircle(currCircle.x, currCircle.y, currCircle.type);
          } else {
            circleIndexesToRemove.push(i);
          }
        }

        for (var j = 0; j < circleIndexesToRemove.length; j++) {
          existingCircles.splice(j, 1);
        }

      }

      function findClosestCircle() {
        var currMin = distanceSquared(vehicle.x, vehicle.y, existingCircles[0].x, existingCircles[0].y);
        var ind = 0;
        for (var i = 1; i < existingCircles.length; i++) {
          var currDist = distanceSquared(vehicle.x, vehicle.y, existingCircles[i].x, existingCircles[i].y)
          if (currDist < currMin) {
            currMin = currDist;
            ind = 0;
          }
        }

        return existingCircles[ind];
      }

      function createCircle() {
        var lifetime = randFromTo(10, 30);
        // Type 1: mine
        var type = 1;

        if (randFromTo(0, 100) > 80) {
          // Type 2: energy
          type = 2;
        }

        var x = randFromTo(circleRadius, canvas.width - circleRadius);
        var y = randFromTo(circleRadius, canvas.height - circleRadius);
        console.log(lifetime);
        return {
          lifetime: lifetime,
          // Type 1 - energy, type 2 - mine
          type: type,
          // if Current time - tStart > lifetime, then do not draw anymore
          tStart: null,
          // x and y coords
          x: x,
          y: y
        }
      }

      function randFromTo(from, to) {
        var range = to - from;
        return Math.ceil(Math.random() * range) + from;
      }

      function drawNumber() {
          // Draw number to the screen
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, 200, 100);
          ctx.font = '25px Arial';
          ctx.fillStyle = 'black';
          // ctx.fillText("sec: " + oldTimeStamp, 10, 30);
      }

      function distanceSquared(x1, y1, x2, y2) {
        return Math.pow(x2 - x1) + Math.pow(y2 - y1);
      }

      function collisionDetection() {
        for (var i = 0; i < existingCircles.length; i++) {
          // Doesn't seem to work well
          // TODO: debug collisions
          if (existingCircles[i].x > vehicle.x && existingCircles[i].x < vehicle.x + vehicle.width &&
            existingCircles[i].y > vehicle.y && existingCircles[i].y < vehicle.y + vehicle.height
            ) {
            console.log('test');
            // debugger;

          }
        }
      }
      // end Helper
    </script>
  </body>
</html>

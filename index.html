<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title></title>
    <style type="text/css">
      canvas { border: 1px solid black; }
    </style>
  </head>
  <body">
    <canvas id="ai" width="800" height="200"></canvas>
    <script type="text/javascript">
      //https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Finishing_up

      // Declare as variable
      var canvas;
      var ctx;
      var secondsPassed;
      var oldTimeStamp;
      var fps;

      var dx = 0.2;
      var dy = -0.2;

      // Circles variables
      var circleRadius = 10;
      var maxCircles = 12;
      var existingCircles = [];
      var BAD = 1;
      var GOOD = 2;
      // end Circles variables

      // Vehicle object
      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rotate
      var vehicle = {
        x: 0,
        y: 0,
        width: 20,
        height: 20,
        velocity: {
          x: 0,
          y: 0
        },
        acceleration: {
          x: 0,
          y: 0
        },
        mass: 5,
        maxSpeed: 20,
        maxForce: 4
      };
      // end Vehicle object


      //
      //


      // Listen to the onLoad event
      window.onload = init;

      // Trigger init function when the page has loaded
      function init() {
        canvas = document.getElementById('ai');
        ctx = canvas.getContext('2d');

        vehicle.x = randFromTo(20, canvas.width - 20);
        vehicle.y = randFromTo(20, canvas.height - 20);

        // Request an animation frame for the first time
        // The gameLoop() function will be called as a callback of this request
        // https://developer.mozilla.org/en-US/docs/Games/Anatomy#building_a_more_optimized_main_loop_in_javascript
        window.requestAnimationFrame(gameLoop);
      }

      function gameLoop(timeStamp) {

        // Calculate the number of seconds passed since the last frame
        oldTimeStamp ||= 0; // First frame
        secondsPassed = (timeStamp - oldTimeStamp) / 1000;
        oldTimeStamp = timeStamp;
        // tNow = timeStamp;

        // // Calculate fps
        // fps = Math.round(1 / secondsPassed);

        // Perform the drawing operation
        draw(timeStamp, secondsPassed);

        // The loop function has reached it's end
        // Keep requesting new frames
        window.requestAnimationFrame(gameLoop);
      }

      function draw(timeStamp, secondsFromLastFrame) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        var ts = timeStamp / 1000;

        updateVehicle(secondsFromLastFrame);
        drawVehicle(ts);
        drawCircles(ts);
        collisionDetection();
      }

      // Vehicle physics
      // https://lamberta.github.io/html5-animation/

      function updateVehicle(ts) {
        // vehicle.force = calculateSteeringForce();
        var target = findClosestCircle();

        // If x or y is 0 ?
        // Does this going to introduce some movement issues?
        if (!target.x || !target.y) {
          return;
        }

        // Regular movement (no force applied)
        // var dx = target.x - vehicle.x;
        // var dy = target.y - vehicle.y;
        // var angle = Math.atan2(dy, dx);

        // vehicle.x += Math.cos(angle) * 1;
        // vehicle.y += Math.sin(angle) * 1;
        //

        // https://github.com/wangchen/Programming-Game-AI-by-Example-src/blob/master/Buckland_Chapter3-Steering%20Behaviors/Vehicle.cpp
        // https://github.com/wangchen/Programming-Game-AI-by-Example-src/blob/master/Buckland_Chapter3-Steering%20Behaviors/SteeringBehaviors.cpp

        vehicle.force = seek(target.x, target.y);
        vehicle.acceleration.x = vehicle.force.x / vehicle.mass;
        vehicle.acceleration.y = vehicle.force.y / vehicle.mass;
        // // Check timeStamp here, should probably be time elapsed from previous frame?
        // // Originally it's m_TimeElapsed = (m_CurrentTime - m_LastTimeInTimeElapsed) * m_TimeScale;
        vehicle.velocity.x += vehicle.acceleration.x * ts;
        vehicle.velocity.y += vehicle.acceleration.y * ts;
        // // Truncate to maxSpeed if needed;
        // truncate();
        // updatePos();
        // Update position
        vehicle.x += vehicle.velocity.x * ts;
        vehicle.y += vehicle.velocity.y * ts;
      }
      // end Vehicle physics

      // AI functions
      function seek(targetX, targetY) {
        var diffX = targetX - vehicle.x;
        var diffY = targetY - vehicle.y;
        var normalized = normalize(diffX, diffY);
        var desiredVelocityX = normalized.x * vehicle.maxSpeed;
        var desiredVelocityY = normalized.y * vehicle.maxSpeed;

        return {
          x: desiredVelocityX - vehicle.velocity.x,
          y: desiredVelocityY - vehicle.velocity.y
        };
      }
      //


      // Helper

      function drawVehicle(ts) {
        ctx.fillStyle = '#ff8080';
        ctx.fillRect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
      }

      function drawCircle(x, y, type) {
        var color = '#880000';
        if (type == 2) {
          color = '#0095DD';
        }

        ctx.beginPath();
        ctx.arc(x, y, circleRadius, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
      }

      function drawCircles(ts) {
        if (randFromTo(0, 1000) > 993 && existingCircles.length < maxCircles) {
          existingCircles.push(createCircle());
        }

        var circleIndexesToRemove = [];

        for (var i = 0; i < existingCircles.length; i++) {
          var currCircle = existingCircles[i];
          currCircle.tStart ||= ts;
          // TODO: check if this works correcly (count seconds for one circle)
          // another option is to have "secondsPassed" and
          // currCircle.timePassed += secondsPassed, then check if timePassed <= lifetime ?
          // The current implementation uses "Static" time? (runs at different speed on different computers) ?
          // https://developer.ibm.com/tutorials/wa-build2dphysicsengine/
          if (ts - currCircle.tStart <= currCircle.lifetime) {
            drawCircle(currCircle.x, currCircle.y, currCircle.type);
          } else {
            circleIndexesToRemove.push(i);
          }
        }

        for (var j = 0; j < circleIndexesToRemove.length; j++) {
          existingCircles.splice(j, 1);
        }

      }

      function findClosestCircle() {
        if (!existingCircles.length) {
          // return { x: canvas.width/2, y: canvas.height/2 };
          return { x: null, y: null };
        }

        // if (existingCircles[i].type === GOOD) {
        //   var currMin = distanceSquared(vehicle.x, vehicle.y, existingCircles[0].x, existingCircles[0].y);
        //   var ind = 0;
        // }
        var result;
        var currMin = Number.MAX_VALUE;
        var ind;
        for (var i = 0; i < existingCircles.length; i++) {
          if (existingCircles[i].type === GOOD) {
            var currDist = distanceSquared(vehicle.x, vehicle.y, existingCircles[i].x, existingCircles[i].y)
            if (currDist < currMin) {
              currMin = currDist;
              ind = i;
              result = existingCircles[ind];
            }
          }
        }

        if (!result) {
          result = { x: null, y: null };
        }

        return result;
      }

      function createCircle() {
        var lifetime = randFromTo(10, 30);
        // Type 1: bad
        var type = BAD;

        if (randFromTo(0, 100) > 80) {
          // Type 2: good
          type = GOOD;
        }

        var x = randFromTo(circleRadius, canvas.width - circleRadius);
        var y = randFromTo(circleRadius, canvas.height - circleRadius);
        console.log(lifetime);
        return {
          lifetime: lifetime,
          // Type 1 - energy, type 2 - mine
          type: type,
          // if Current time - tStart > lifetime, then do not draw anymore
          tStart: null,
          // x and y coords
          x: x,
          y: y
        }
      }

      function randFromTo(from, to) {
        var range = to - from;
        return Math.ceil(Math.random() * range) + from;
      }

      function drawNumber() {
          // Draw number to the screen
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, 200, 100);
          ctx.font = '25px Arial';
          ctx.fillStyle = 'black';
          // ctx.fillText("sec: " + oldTimeStamp, 10, 30);
      }

      function distanceSquared(x1, y1, x2, y2) {
        return Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
      }

      function collisionDetection() {
        for (var i = 0; i < existingCircles.length; i++) {
          // Doesn't seem to work well
          // TODO: debug collisions
          if (existingCircles[i].x > vehicle.x && existingCircles[i].x < vehicle.x + vehicle.width &&
            existingCircles[i].y > vehicle.y && existingCircles[i].y < vehicle.y + vehicle.height
            ) {
            console.log('test');
            // debugger;

          }
        }
      }

      function vecLength(x, y) {
        return Math.sqrt(x*x + y*y);
      }

      function normalize(x, y) {
        var len = vecLength(x, y);
        return {
          x: x / len,
          y: y / len
        }
      }
      // end Helper
    </script>
  </body>
</html>
